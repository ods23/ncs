const express = require('express');
const { pool } = require('../config/database');
const XLSX = require('xlsx');
const { convertDateField, processExcelData } = require('../utils/excelUtils');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// 전입신자 목록 조회
router.get('/', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { year, name, education_type, phone } = req.query;
    
    conn = await pool.getConnection();
    
    let sql = `
      SELECT 
        id,
        department,
        '전입신자' as believer_type,
        education_type,
        year,
        name,
        gender,
        marital_status,
        DATE_FORMAT(birth_date, '%Y-%m-%d') as birth_date,
        address,
        phone,
        teacher,
        DATE_FORMAT(register_date, '%Y-%m-%d') as register_date,
        DATE_FORMAT(education_start_date, '%Y-%m-%d') as education_start_date,
        DATE_FORMAT(education_end_date, '%Y-%m-%d') as education_end_date,
        affiliation_org,
        belong,
        DATE_FORMAT(new_life_strategy_date, '%Y-%m-%d') as new_life_strategy_date,
        identity_verified,
        prev_church,
        comment,
        graduate_transfer_status,
        number,
        file_id,
        created_at,
        updated_at
      FROM new_comers 
      WHERE believer_type = '전입신자' AND department = '새가족위원회'
    `;
    
    const params = [];
    
    // 년도 조건
    if (year && year.trim() !== '') {
      sql += ' AND year = ?';
      params.push(year);
    }
    
    // 이름 조건 (부분 검색)
    if (name && name.trim() !== '') {
      sql += ' AND name LIKE ?';
      params.push(`%${name}%`);
    }
    
    // 교육구분 조건
    if (education_type && education_type.trim() !== '') {
      sql += ' AND education_type = ?';
      params.push(education_type);
    }
    
    // 전화번호 조건 (부분 검색)
    if (phone && phone.trim() !== '') {
      sql += ' AND phone LIKE ?';
      params.push(`%${phone}%`);
    }
    
    sql += ' ORDER BY number ASC';
    
    console.log('전입신자 조회 SQL:', sql);
    console.log('전입신자 조회 파라미터:', params);
    
    const rows = await conn.query(sql, params);
    res.json(rows);
  } catch (error) {
    console.error('전입신자 목록 조회 실패:', error);
    res.status(500).json({ error: '전입신자 목록 조회 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 개별 전입신자 조회
router.get('/:id', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { id } = req.params;
    
    conn = await pool.getConnection();
    
    const sql = `
      SELECT 
        id,
        department,
        '전입신자' as believer_type,
        education_type,
        year,
        name,
        gender,
        marital_status,
        DATE_FORMAT(birth_date, '%Y-%m-%d') as birth_date,
        address,
        phone,
        teacher,
        DATE_FORMAT(register_date, '%Y-%m-%d') as register_date,
        DATE_FORMAT(education_start_date, '%Y-%m-%d') as education_start_date,
        DATE_FORMAT(education_end_date, '%Y-%m-%d') as education_end_date,
        affiliation_org,
        belong,
        DATE_FORMAT(new_life_strategy_date, '%Y-%m-%d') as new_life_strategy_date,
        identity_verified,
        prev_church,
        comment,
        graduate_transfer_status,
        number,
        file_id,
        created_at,
        updated_at
      FROM new_comers 
      WHERE id = ? AND believer_type = '전입신자'
    `;
    
    const rows = await conn.query(sql, [id]);
    
    if (rows.length === 0) {
      return res.status(404).json({ error: '전입신자를 찾을 수 없습니다.' });
    }
    
    res.json(rows[0]);
  } catch (error) {
    console.error('전입신자 조회 실패:', error);
    res.status(500).json({ error: '전입신자 정보를 가져오는 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 생성
router.post('/', authenticateToken, async (req, res) => {
  let conn;
  try {
    const {
      department,
      believer_type,
      education_type,
      year,
      name,
      gender,
      marital_status,
      birth_date,
      address,
      phone,
      teacher,
      register_date,
      education_start_date,
      education_end_date,
      affiliation_org,
      belong,
      new_life_strategy_date,
      identity_verified,
      prev_church,
      comment,
      graduate_transfer_status,
      file_id
    } = req.body;
    
    console.log('받은 데이터:', req.body);
    console.log('추출된 필드들:', {
      department, believer_type, education_type, year, name, gender, marital_status,
      birth_date, address, phone, teacher, register_date, education_start_date,
      education_end_date, affiliation_org, belong, new_life_strategy_date,
      identity_verified, prev_church, comment, graduate_transfer_status, file_id
    });
    
    conn = await pool.getConnection();
    
    // 날짜 필드가 빈 문자열이면 null로 변환, null이면 null로 유지
    const finalBirthDate = birth_date === '' ? null : birth_date;
    const finalRegisterDate = register_date === '' ? null : register_date;
    const finalEducationStartDate = education_start_date === '' ? null : education_start_date;
    const finalEducationEndDate = education_end_date === '' ? null : education_end_date;
    const finalNewLifeStrategyDate = new_life_strategy_date === '' ? null : new_life_strategy_date;

    // 부서, 신자유형, 년도를 기준으로 번호 생성
    const yearSuffix = year ? year.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
    
    // 부서, 신자유형, 년도 기준으로 순번 조회
    const rowNumberResult = await conn.query(`
      SELECT COUNT(*) + 1 as seq_number
      FROM new_comers 
      WHERE department = ? AND believer_type = ? AND year = ?
    `, [department, believer_type, year]);
    
    const rowNumber = rowNumberResult[0]?.seq_number || 1;
    const number = `${yearSuffix}-${String(rowNumber).padStart(3, '0')}`;

    const sql = `
      INSERT INTO new_comers (
        department, believer_type, education_type, year, name, gender, marital_status,
        birth_date, address, phone, teacher, register_date, education_start_date,
        education_end_date, affiliation_org, belong, new_life_strategy_date,
        identity_verified, prev_church, comment, graduate_transfer_status, number, file_id
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    
    const params = [
      department, believer_type, education_type, year, name, gender, marital_status,
      finalBirthDate, address, phone, teacher, finalRegisterDate, finalEducationStartDate,
      finalEducationEndDate, affiliation_org, belong, finalNewLifeStrategyDate,
      identity_verified, prev_church, comment, graduate_transfer_status, number, file_id
    ];
    
    console.log('INSERT 파라미터:', params);
    console.log('파라미터 개수:', params.length);
    console.log('SQL VALUES 개수:', sql.match(/\?/g)?.length || 0);
    
    const result = await conn.query(sql, params);
    
    res.status(201).json({
      id: result.insertId,
      message: '전입신자가 성공적으로 등록되었습니다.',
      number: number
    });
  } catch (error) {
    console.error('전입신자 등록 실패:', error);
    res.status(500).json({ error: '전입신자 등록 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 수정
router.put('/:id', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { id } = req.params;
    const {
      department,
      believer_type,
      education_type,
      year,
      name,
      gender,
      marital_status,
      birth_date,
      address,
      phone,
      teacher,
      register_date,
      education_start_date,
      education_end_date,
      affiliation_org,
      belong,
      new_life_strategy_date,
      identity_verified,
      prev_church,
      comment,
      graduate_transfer_status,
      number,
      file_id
    } = req.body;
    
    conn = await pool.getConnection();
    
    // 기존 데이터 조회 (신자구분 변경 확인용)
    const existingDataResult = await conn.query('SELECT believer_type, number, year, department FROM new_comers WHERE id = ?', [id]);
    const existingBelieverType = existingDataResult[0]?.believer_type;
    const originalNumber = existingDataResult[0]?.number;
    const existingYear = existingDataResult[0]?.year;
    const existingDepartment = existingDataResult[0]?.department;
    
    console.log('=== 전입신자 수정 시작 ===');
    console.log('기존 신자구분:', existingBelieverType);
    console.log('새 신자구분:', believer_type);
    console.log('기존 번호:', originalNumber);
    console.log('요청 번호:', number);
    
    // 신자구분에 따른 번호 처리
    let finalNumber = number;
    let shouldReorderNumbers = false;
    
    if (existingBelieverType !== believer_type) {
      console.log('신자구분 변경 감지');
      
      if (existingBelieverType === '전입신자' && believer_type === '초신자') {
        // 전입신자 → 초신자: 새로운 초신자 번호 생성
        console.log('전입신자 → 초신자 변경: 새로운 번호 생성');
        shouldReorderNumbers = true;
        
        // 년도에서 마지막 2자리 추출
        const yearSuffix = existingYear ? existingYear.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
        
        // 부서, 신자유형(초신자), 년도 기준으로 순번 조회
        const rowNumberQuery = `
          SELECT COUNT(*) as current_count
          FROM new_comers 
          WHERE department = ? AND believer_type = ? AND year = ?
        `;
        
        const rowNumberResult = await conn.query(rowNumberQuery, [existingDepartment, believer_type, existingYear]);
        const currentCount = parseInt(rowNumberResult[0]?.current_count) || 0;
        const nextNumber = currentCount + 1;
        finalNumber = `${yearSuffix}-${String(nextNumber).padStart(3, '0')}`;
        
        console.log('초신자 현재 등록된 수:', currentCount);
        console.log('초신자 다음 순번:', nextNumber);
        console.log('초신자 생성된 번호:', finalNumber);
      } else if (existingBelieverType === '초신자' && believer_type === '전입신자') {
        // 초신자 → 전입신자: 새로운 전입신자 번호 생성
        console.log('초신자 → 전입신자 변경: 새로운 번호 생성');
        shouldReorderNumbers = true;
        
        // 년도에서 마지막 2자리 추출
        const yearSuffix = existingYear ? existingYear.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
        
        // 부서, 신자유형(전입신자), 년도 기준으로 순번 조회
        const rowNumberQuery = `
          SELECT COUNT(*) as current_count
          FROM new_comers 
          WHERE department = ? AND believer_type = ? AND year = ?
        `;
        
        const rowNumberResult = await conn.query(rowNumberQuery, [existingDepartment, believer_type, existingYear]);
        const currentCount = parseInt(rowNumberResult[0]?.current_count) || 0;
        const nextNumber = currentCount + 1;
        finalNumber = `${yearSuffix}-${String(nextNumber).padStart(3, '0')}`;
        
        console.log('전입신자 현재 등록된 수:', currentCount);
        console.log('전입신자 다음 순번:', nextNumber);
        console.log('전입신자 생성된 번호:', finalNumber);
      }
    }
    
    // 날짜 필드가 빈 문자열이면 null로 변환, null이면 null로 유지
    const finalBirthDate = birth_date === '' ? null : birth_date;
    const finalRegisterDate = register_date === '' ? null : register_date;
    const finalEducationStartDate = education_start_date === '' ? null : education_start_date;
    const finalEducationEndDate = education_end_date === '' ? null : education_end_date;
    const finalNewLifeStrategyDate = new_life_strategy_date === '' ? null : new_life_strategy_date;

    const sql = `
      UPDATE new_comers SET
        department = ?, believer_type = ?, education_type = ?, year = ?, name = ?, 
        gender = ?, marital_status = ?, birth_date = ?, address = ?, phone = ?, 
        teacher = ?, register_date = ?, education_start_date = ?, education_end_date = ?, 
        affiliation_org = ?, belong = ?, new_life_strategy_date = ?, identity_verified = ?, 
        prev_church = ?, comment = ?, graduate_transfer_status = ?, number = ?, file_id = ?, 
        updated_at = NOW()
      WHERE id = ?
    `;
    
    const params = [
      department, believer_type, education_type, year, name, gender, marital_status,
      finalBirthDate, address, phone, teacher, finalRegisterDate, finalEducationStartDate,
      finalEducationEndDate, affiliation_org, belong, finalNewLifeStrategyDate,
      identity_verified, prev_church, comment, graduate_transfer_status, finalNumber, file_id, id
    ];
    
    const result = await conn.query(sql, params);
    
    if (result.affectedRows === 0) {
      return res.status(404).json({ error: '전입신자를 찾을 수 없습니다.' });
    }
    
    // 신자구분 변경으로 인한 번호 재정렬
    if (shouldReorderNumbers) {
      console.log('=== 번호 재정렬 시작 ===');
      
      // 전입신자 → 초신자 변경인 경우 전입신자 번호 재정렬
      if (existingBelieverType === '전입신자' && believer_type === '초신자') {
        console.log('전입신자 → 초신자 변경: 전입신자 번호 재정렬');
        try {
          const reorderResponse = await fetch(`${req.protocol}://${req.get('host')}/api/transfer-believers/reorder-numbers`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': req.headers.authorization
            },
            body: JSON.stringify({
              year: existingYear,
              department: existingDepartment
            })
          });
          
          if (reorderResponse.ok) {
            const reorderData = await reorderResponse.json();
            console.log('전입신자 번호 재정렬 완료:', reorderData.message);
            console.log('재정렬된 전입신자 수:', reorderData.updatedCount);
          } else {
            console.error('전입신자 번호 재정렬 실패');
          }
        } catch (error) {
          console.error('전입신자 번호 재정렬 중 오류:', error);
        }
      }
      // 초신자 → 전입신자 변경인 경우 초신자 번호 재정렬
      else if (existingBelieverType === '초신자' && believer_type === '전입신자') {
        console.log('초신자 → 전입신자 변경: 초신자 번호 재정렬');
        try {
          const reorderResponse = await fetch(`${req.protocol}://${req.get('host')}/api/new-comers/reorder-numbers`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': req.headers.authorization
            },
            body: JSON.stringify({
              year: existingYear,
              department: existingDepartment
            })
          });
          
          if (reorderResponse.ok) {
            const reorderData = await reorderResponse.json();
            console.log('초신자 번호 재정렬 완료:', reorderData.message);
            console.log('재정렬된 초신자 수:', reorderData.updatedCount);
          } else {
            console.error('초신자 번호 재정렬 실패');
          }
        } catch (error) {
          console.error('초신자 번호 재정렬 중 오류:', error);
        }
      }
    }
    
    // 신자구분 변경으로 인한 번호 업데이트가 있는 경우 응답에 포함
    const responseData = { message: '전입신자 정보가 성공적으로 수정되었습니다.' };
    if (existingBelieverType !== believer_type) {
      responseData.number = finalNumber;
      responseData.believer_type = believer_type;
      console.log('신자구분 변경으로 번호 업데이트:', finalNumber);
    }
    
    res.json(responseData);
  } catch (error) {
    console.error('전입신자 수정 실패:', error);
    res.status(500).json({ error: '전입신자 수정 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 수료 전송
router.post('/:id/graduate', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { id } = req.params;
    const graduateData = req.body;
    
    console.log('=== 전입신자 수료 전송 요청 ===');
    console.log('전입신자 ID:', id);
    console.log('전송 데이터:', graduateData);
    
    conn = await pool.getConnection();
    
    // 전입신자 정보 조회
    const transferBelieverResult = await conn.query('SELECT * FROM new_comers WHERE id = ? AND believer_type = "전입신자"', [id]);
    const transferBeliever = Array.isArray(transferBelieverResult) ? transferBelieverResult : transferBelieverResult.rows || [];
    
    if (transferBeliever.length === 0) {
      return res.status(404).json({ error: '전입신자를 찾을 수 없습니다.' });
    }
    
    // 수료번호 생성 (년도, 부서, 신자 기준으로 순번 매기기)
    const year = graduateData.year || new Date().getFullYear().toString();
    const shortYear = year.slice(-2); // 년도의 마지막 2자리
    
    console.log('=== 수료번호 생성 시작 ===');
    console.log('년도:', year);
    console.log('부서:', graduateData.department);
    console.log('신자:', graduateData.believer_type);
    
    // 같은 년도, 부서, 신자에서 최대 순번 조회
    const maxNumberQuery = `
      SELECT COUNT(*) as max_num
      FROM new_comers_graduates 
      WHERE year = ? AND department = ? AND believer_type = ?
    `;
    
    console.log('최대 순번 조회 쿼리:', maxNumberQuery);
    console.log('조회 파라미터:', [year, graduateData.department, graduateData.believer_type]);
    
    const maxNumberResult = await conn.query(maxNumberQuery, [
      year,
      graduateData.department,
      graduateData.believer_type
    ]);
    
    console.log('최대 순번 조회 결과:', maxNumberResult);
    
    let currentMax = 0;
    
    if (maxNumberResult && maxNumberResult.length > 0) {
      currentMax = parseInt(maxNumberResult[0].max_num);
      console.log('현재 최대 순번 (DB에서 조회):', currentMax, '타입:', typeof currentMax);
    }
    
    const nextNumber = currentMax + 1;
    const graduateNumber = `${shortYear}-${String(nextNumber).padStart(3, '0')}`;
    
    console.log('현재 최대 순번:', currentMax);
    console.log('다음 순번:', nextNumber);
    console.log('생성된 수료번호:', graduateNumber);
    console.log('=== 수료번호 생성 완료 ===');
    
    // 수료자 테이블에 데이터 삽입
    const insertQuery = `
      INSERT INTO new_comers_graduates (
        graduate_number, department, believer_type, education_type, year, name, gender, marital_status,
        birth_date, address, phone, teacher, register_date, education_start_date,
        education_end_date, affiliation_org, belong, new_life_strategy_date,
        identity_verified, prev_church, comment, new_comer_id
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
    
    const insertValues = [
      graduateNumber,
      graduateData.department,
      graduateData.believer_type,
      graduateData.education_type,
      graduateData.year,
      graduateData.name,
      graduateData.gender,
      graduateData.marital_status,
      graduateData.birth_date,
      graduateData.address,
      graduateData.phone,
      graduateData.teacher,
      graduateData.register_date,
      graduateData.education_start_date,
      graduateData.education_end_date,
      graduateData.affiliation_org,
      graduateData.belong,
      graduateData.new_life_strategy_date,
      graduateData.identity_verified,
      graduateData.prev_church,
      graduateData.comment,
      id
    ];
    
    const insertResult = await conn.query(insertQuery, insertValues);
    const result = Array.isArray(insertResult) ? insertResult : insertResult.rows || [];
    
    // 전입신자 상태를 수료로 변경
    await conn.query(
      'UPDATE new_comers SET education_type = ?, graduate_transfer_status = ? WHERE id = ?',
      ['수료', '전송완료', id]
    );
    
    const insertId = insertResult.insertId || (Array.isArray(insertResult) ? insertResult[0]?.insertId : null);
    
    res.status(201).json({
      message: '수료 전송이 완료되었습니다.',
      graduateId: insertId,
      graduateNumber: graduateNumber
    });
  } catch (error) {
    console.error('수료 전송 실패:', error);
    res.status(500).json({ error: '수료 전송 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 삭제
router.delete('/:id', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { id } = req.params;
    
    conn = await pool.getConnection();
    
    // 전입신자 정보 조회 (파일 ID 포함)
    const checkSql = 'SELECT education_type, file_id FROM new_comers WHERE id = ? AND believer_type = "전입신자"';
    const checkResult = await conn.query(checkSql, [id]);
    
    if (checkResult.length === 0) {
      return res.status(404).json({ error: '전입신자를 찾을 수 없습니다.' });
    }
    
    if (checkResult[0].education_type === '수료') {
      return res.status(400).json({ error: '수료된 전입신자는 삭제할 수 없습니다.' });
    }
    
    const fileId = checkResult[0].file_id;
    
    // 트랜잭션 시작
    await conn.beginTransaction();
    
    try {
      // 전입신자 삭제
      const deleteSql = 'DELETE FROM new_comers WHERE id = ? AND believer_type = "전입신자"';
      const result = await conn.query(deleteSql, [id]);
      
      if (result.affectedRows === 0) {
        await conn.rollback();
        return res.status(404).json({ error: '전입신자를 찾을 수 없습니다.' });
      }
      
      // 파일이 연결되어 있으면 파일도 삭제
      if (fileId && fileId !== null && fileId !== undefined) {
        console.log('파일 ID 확인:', fileId);
        
        // 파일 정보 조회
        const fileSql = 'SELECT saved_path FROM new_comer_files WHERE id = ?';
        const fileResult = await conn.query(fileSql, [fileId]);
        
        console.log('파일 조회 결과:', fileResult);
        
        if (fileResult.length > 0) {
          const filePath = fileResult[0].saved_path;
          console.log('파일 경로:', filePath);
          
          // 실제 파일 삭제
          const fs = require('fs');
          const path = require('path');
          const fullPath = filePath; // saved_path는 이미 전체 경로를 포함하고 있음
          
          console.log('전체 파일 경로:', fullPath);
          
          try {
            if (fs.existsSync(fullPath)) {
              fs.unlinkSync(fullPath);
              console.log('실제 파일 삭제 완료:', fullPath);
            } else {
              console.log('파일이 존재하지 않음:', fullPath);
            }
          } catch (fileError) {
            console.error('실제 파일 삭제 실패:', fileError);
            // 파일 삭제 실패해도 DB 삭제는 계속 진행
          }
          
          // 파일 DB 레코드 삭제
          const deleteFileSql = 'DELETE FROM new_comer_files WHERE id = ?';
          await conn.query(deleteFileSql, [fileId]);
          console.log('파일 DB 레코드 삭제 완료:', fileId);
        } else {
          console.log('파일 DB에서 파일을 찾을 수 없음:', fileId);
        }
      } else {
        console.log('파일 ID가 없음:', fileId);
      }
      
      // 트랜잭션 커밋
      await conn.commit();
      
      res.json({ message: '전입신자가 성공적으로 삭제되었습니다.' });
    } catch (error) {
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('전입신자 삭제 실패:', error);
    res.status(500).json({ error: '전입신자 삭제 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// Excel 업로드 (전입신자만)
router.post('/upload', authenticateToken, async (req, res) => {
  let conn;
  try {
    const excelData = req.body;
    
    if (!Array.isArray(excelData) || excelData.length === 0) {
      return res.status(400).json({ error: '업로드할 데이터가 없습니다.' });
    }

    console.log('받은 엑셀 데이터:', excelData.length, '행');
    console.log('첫 번째 행 샘플:', excelData[0]);

    conn = await pool.getConnection();
    await conn.beginTransaction();

    let successCount = 0;
    let failCount = 0;
    const errors = [];

    try {
      for (let i = 0; i < excelData.length; i++) {
        const row = excelData[i];
        
        // NFC 정규화 및 날짜 변환 적용
        const processedRow = processExcelData(row, ['생년월일', '등록신청일', '양육시작일', '교육시작일', '양육종료일', '교육기간', '새생명전략', 'birth_date', 'register_date', 'education_start_date', 'education_end_date', 'new_life_strategy_date']);
        
        // 한글 헤더와 영문 필드명 매핑
        const mappedRow = {
          department: processedRow['부서'] || processedRow.department,
          education_type: processedRow['교육'] || processedRow.education_type,
          year: processedRow['년도'] || processedRow.year,
          name: processedRow['이름'] || processedRow.name,
          gender: processedRow['성별'] || processedRow.gender,
          marital_status: processedRow['결혼'] || processedRow.marital_status,
          birth_date: convertDateField(processedRow['생년월일'] || processedRow.birth_date),
          address: processedRow['주소'] || processedRow.address,
          phone: processedRow['전화번호'] || processedRow['전화'] || processedRow.phone,
          teacher: processedRow['양육교사'] || processedRow['담당교사'] || processedRow.teacher,
          register_date: convertDateField(processedRow['등록신청일'] || processedRow.register_date),
          education_start_date: convertDateField(processedRow['양육시작일'] || processedRow['교육시작일'] || processedRow.education_start_date),
          education_end_date: convertDateField(processedRow['양육종료일'] || processedRow['교육기간'] || processedRow.education_end_date),
          affiliation_org: processedRow['편입기관'] || processedRow.affiliation_org,
          belong: processedRow['소속'] || processedRow.belong,
          new_life_strategy_date: convertDateField(processedRow['새생명전략'] || processedRow.new_life_strategy_date),
          identity_verified: processedRow['본인확인'] || processedRow.identity_verified || 0,
          prev_church: processedRow['이전교회'] || processedRow.prev_church || '',
          comment: processedRow['비고'] || processedRow.comment || '',
          graduate_transfer_status: processedRow['수료전송상태'] || processedRow.graduate_transfer_status || '전송대기',
          file_id: null
        };

        // 필수 필드 검증
        if (!mappedRow.name || !mappedRow.department || !mappedRow.year) {
          errors.push(`행 ${i + 1}: 이름, 부서, 년도는 필수입니다.`);
          failCount++;
          continue;
        }

        // 부서, 신자유형, 년도 기준으로 순번 조회
        const rowNumberResult = await conn.query(`
          SELECT COUNT(*) + 1 as seq_number
          FROM new_comers 
          WHERE department = ? AND believer_type = ? AND year = ?
        `, [mappedRow.department, '전입신자', mappedRow.year]);
        
        const rowNumber = rowNumberResult[0]?.seq_number || 1;
        const yearSuffix = mappedRow.year ? mappedRow.year.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
        const number = `${yearSuffix}-${String(rowNumber).padStart(3, '0')}`;

        const insertSql = `
          INSERT INTO new_comers (
            department, believer_type, education_type, year, name, gender, marital_status,
            birth_date, address, phone, teacher, register_date, education_start_date,
            education_end_date, affiliation_org, belong, new_life_strategy_date,
            identity_verified, prev_church, comment, graduate_transfer_status, number, file_id
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        
        const insertParams = [
          mappedRow.department, '전입신자', mappedRow.education_type, mappedRow.year,
          mappedRow.name, mappedRow.gender, mappedRow.marital_status, mappedRow.birth_date,
          mappedRow.address, mappedRow.phone, mappedRow.teacher, mappedRow.register_date,
          mappedRow.education_start_date, mappedRow.education_end_date, mappedRow.affiliation_org,
          mappedRow.belong, mappedRow.new_life_strategy_date, mappedRow.identity_verified,
          mappedRow.prev_church, mappedRow.comment, mappedRow.graduate_transfer_status,
          number, mappedRow.file_id
        ];
        
        console.log('Excel INSERT 파라미터:', insertParams);
        console.log('Excel 파라미터 개수:', insertParams.length);
        console.log('Excel SQL VALUES 개수:', insertSql.match(/\?/g)?.length || 0);
        
        await conn.query(insertSql, insertParams);
        successCount++;
      }
      
      await conn.commit();
      
      res.json({
        message: 'Excel 업로드가 완료되었습니다.',
        successCount,
        failCount,
        errors: errors.length > 0 ? errors : undefined
      });
    } catch (error) {
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Excel 업로드 실패:', error);
    res.status(500).json({ error: 'Excel 업로드 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// Excel 다운로드
router.get('/download/excel', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { year, department, education_type } = req.query;
    
    conn = await pool.getConnection();
    
    let sql = `
      SELECT 
        department as '부서',
        '전입신자' as '신자구분',
        education_type as '교육구분',
        year as '년도',
        name as '이름',
        gender as '성별',
        marital_status as '결혼상태',
        DATE_FORMAT(birth_date, '%Y-%m-%d') as '생년월일',
        address as '주소',
        phone as '전화번호',
        teacher as '담당교사',
        DATE_FORMAT(register_date, '%Y-%m-%d') as '등록신청일',
        DATE_FORMAT(education_start_date, '%Y-%m-%d') as '양육시작일',
        DATE_FORMAT(education_end_date, '%Y-%m-%d') as '양육종료일',
        affiliation_org as '편입기관',
        belong as '소속',
        DATE_FORMAT(new_life_strategy_date, '%Y-%m-%d') as '새생명전략',
        identity_verified as '본인확인',
        prev_church as '이전교회',
        comment as '비고',
        graduate_transfer_status as '수료전송상태',
        number as '번호'
      FROM new_comers 
      WHERE believer_type = '전입신자'
    `;
    
    const params = [];
    
    // 년도 조건
    if (year && year.trim() !== '') {
      sql += ' AND year = ?';
      params.push(year);
    }
    
    // 부서 조건
    if (department && department.trim() !== '') {
      sql += ' AND department = ?';
      params.push(department);
    }
    
    // 교육구분 조건
    if (education_type && education_type.trim() !== '') {
      sql += ' AND education_type = ?';
      params.push(education_type);
    }
    
    sql += ' ORDER BY year DESC, department, name';
    
    console.log('전입신자 Excel 다운로드 SQL:', sql);
    console.log('전입신자 Excel 다운로드 파라미터:', params);
    
    const rows = await conn.query(sql, params);
    
    if (rows.length === 0) {
      return res.status(404).json({ error: '다운로드할 데이터가 없습니다.' });
    }
    
    // Excel 워크북 생성
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.json_to_sheet(rows);
    
    // 컬럼 너비 자동 조정
    const columnWidths = [];
    rows.forEach(row => {
      Object.keys(row).forEach((key, index) => {
        if (!columnWidths[index]) columnWidths[index] = 0;
        const cellLength = String(row[key]).length;
        columnWidths[index] = Math.max(columnWidths[index], cellLength);
      });
    });
    
    worksheet['!cols'] = columnWidths.map(width => ({ width: Math.min(width + 2, 50) }));
    
    XLSX.utils.book_append_sheet(workbook, worksheet, '전입신자목록');
    
    // Excel 파일 생성
    const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
    
    // 파일명 설정 (현재 날짜 포함)
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const filename = `전입신자목록_${dateStr}.xlsx`;
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(excelBuffer);
  } catch (error) {
    console.error('Excel 다운로드 실패:', error);
    res.status(500).json({ error: 'Excel 다운로드 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 담당교사 목록 조회
router.get('/teachers', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { department, believer_type } = req.query;
    
    conn = await pool.getConnection();
    
    let sql = `
      SELECT DISTINCT 
        teacher as name,
        '담당교사' as position
      FROM new_comers 
      WHERE believer_type = '전입신자'
        AND teacher IS NOT NULL 
        AND teacher != ''
    `;
    
    const params = [];
    
    // 부서 조건
    if (department && department.trim() !== '') {
      sql += ' AND department = ?';
      params.push(department);
    }
    
    // 신자구분 조건 (전입신자로 고정)
    sql += ' AND believer_type = ?';
    params.push('전입신자');
    
    sql += ' ORDER BY teacher';
    
    console.log('전입신자 교사 조회 SQL:', sql);
    console.log('전입신자 교사 조회 파라미터:', params);
    
    const rows = await conn.query(sql, params);
    res.json(rows);
  } catch (error) {
    console.error('전입신자 교사 목록 조회 실패:', error);
    res.status(500).json({ error: '전입신자 교사 목록 조회 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 통계 요약 조회
router.get('/statistics/summary', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { year } = req.query;
    
    conn = await pool.getConnection();
    
    let sql = `
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN education_type = '진행중' THEN 1 ELSE 0 END) as in_progress,
        SUM(CASE WHEN education_type = '수료' THEN 1 ELSE 0 END) as completed,
        SUM(CASE WHEN education_type = '중단' THEN 1 ELSE 0 END) as discontinued
      FROM new_comers 
      WHERE believer_type = '전입신자'
    `;
    
    const params = [];
    
    // 년도 조건
    if (year && year.trim() !== '') {
      sql += ' AND year = ?';
      params.push(year);
    }
    
    console.log('전입신자 통계 SQL:', sql);
    console.log('전입신자 통계 파라미터:', params);
    
    const rows = await conn.query(sql, params);
    
    if (rows.length === 0) {
      return res.json({
        total: 0,
        in_progress: 0,
        completed: 0,
        discontinued: 0
      });
    }
    
    const stats = rows[0];
    
    res.json({
      total: stats.total || 0,
      in_progress: stats.in_progress || 0,
      completed: stats.completed || 0,
      discontinued: stats.discontinued || 0
    });
  } catch (error) {
    console.error('전입신자 통계 조회 실패:', error);
    res.status(500).json({ error: '전입신자 통계 조회 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 번호 재정렬 API
router.post('/reorder-numbers', authenticateToken, async (req, res) => {
  let conn;
  try {
    const { year, department } = req.body;
    
    console.log('=== 전입신자 번호 재정렬 시작 ===');
    console.log('년도:', year);
    console.log('부서:', department);
    
    if (!year || !department) {
      return res.status(400).json({ error: '년도와 부서는 필수입니다.' });
    }
    
    conn = await pool.getConnection();
    
    // 트랜잭션 시작
    await conn.beginTransaction();
    
    try {
      // 해당 년도, 부서의 전입신자 목록 조회 (ID 순으로 정렬)
      const selectQuery = `
        SELECT id, name, number
        FROM new_comers 
        WHERE year = ? AND department = ? AND believer_type = '전입신자'
        ORDER BY id ASC
      `;
      
      const transferBelievers = await conn.query(selectQuery, [year, department]);
      
      console.log('재정렬 대상 전입신자 수:', transferBelievers.length);
      
      // 년도에서 마지막 2자리 추출
      const yearSuffix = year.toString().slice(-2);
      
      // 각 전입신자에 대해 순차적으로 번호 재할당
      for (let i = 0; i < transferBelievers.length; i++) {
        const transferBeliever = transferBelievers[i];
        const newNumber = `${yearSuffix}-${String(i + 1).padStart(3, '0')}`;
        
        console.log(`전입신자 ${transferBeliever.name}: ${transferBeliever.number} → ${newNumber}`);
        
        // 번호 업데이트
        await conn.query(
          'UPDATE new_comers SET number = ? WHERE id = ?',
          [newNumber, transferBeliever.id]
        );
      }
      
      // 트랜잭션 커밋
      await conn.commit();
      
      console.log('=== 전입신자 번호 재정렬 완료 ===');
      
      res.json({ 
        message: '전입신자 번호가 성공적으로 재정렬되었습니다.',
        updatedCount: transferBelievers.length
      });
      
    } catch (error) {
      // 트랜잭션 롤백
      await conn.rollback();
      throw error;
    }
    
  } catch (error) {
    console.error('전입신자 번호 재정렬 실패:', error);
    res.status(500).json({ error: '전입신자 번호 재정렬 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 교육 관리 목록 조회
router.get('/education/list', authenticateToken, async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT 
        nc.id,
        nc.teacher,
        nc.name as believer_name,
        nc.believer_type,
        nc.education_type,
        nc.number as registration_number,
        DATE_FORMAT(nc.register_date, '%Y-%m-%d') as registration_date,
        DATE_FORMAT(nc.education_start_date, '%Y-%m-%d') as education_start_date,
        nc.year,
        DATE_FORMAT(nce.week1_date, '%Y-%m-%d') as week1_date,
        DATE_FORMAT(nce.week2_date, '%Y-%m-%d') as week2_date,
        DATE_FORMAT(nce.week3_date, '%Y-%m-%d') as week3_date,
        DATE_FORMAT(nce.week4_date, '%Y-%m-%d') as week4_date,
        DATE_FORMAT(nce.week5_date, '%Y-%m-%d') as week5_date,
        DATE_FORMAT(nce.week6_date, '%Y-%m-%d') as week6_date,
        DATE_FORMAT(nce.week7_date, '%Y-%m-%d') as week7_date,
        DATE_FORMAT(nce.week8_date, '%Y-%m-%d') as week8_date,
        nce.week1_comment,
        nce.week2_comment,
        nce.week3_comment,
        nce.week4_comment,
        nce.week5_comment,
        nce.week6_comment,
        nce.week7_comment,
        nce.week8_comment,
        nce.overall_comment,
        nce.file_id as education_file_id,
        nc.file_id,
        nc.created_at,
        nc.updated_at
      FROM new_comers nc
      LEFT JOIN new_comer_education nce ON nc.id = nce.new_comer_id
      WHERE nc.department = '새가족위원회'
        AND nc.believer_type = '전입신자'
    `;
    
    const params = [];
    
    // 년도 필터
    if (req.query.year && req.query.year.trim() !== '') {
      query += ` AND nc.year = ?`;
      params.push(parseInt(req.query.year.trim()));
    } else {
      // 년도가 지정되지 않은 경우 현재 년도로 기본 설정
      const currentYear = new Date().getFullYear();
      query += ` AND nc.year = ?`;
      params.push(currentYear);
    }
    
    // 교육구분 필터
    if (req.query.education_type && req.query.education_type.trim() !== '') {
      query += ` AND nc.education_type = ?`;
      params.push(req.query.education_type.trim());
    }
    
    // 양육교사명 필터
    if (req.query.teacher && req.query.teacher.trim() !== '') {
      query += ` AND nc.teacher LIKE ?`;
      params.push(`%${req.query.teacher.trim()}%`);
    }
    
    // 전입신자명 필터
    if (req.query.believer_name && req.query.believer_name.trim() !== '') {
      query += ` AND nc.name LIKE ?`;
      params.push(`%${req.query.believer_name.trim()}%`);
    }
    
    // 기본 정렬: 양육교사, 등록번호 오름차순 (초신자 교육 관리와 동일)
    query += ` ORDER BY nc.teacher ASC, nc.number ASC`;
    
    console.log('전입신자 교육 관리 조회 SQL:', query);
    console.log('전입신자 교육 관리 조회 파라미터:', params);
    
    const rows = await conn.query(query, params);
    res.json(rows);
  } catch (error) {
    console.error('전입신자 교육 관리 목록 조회 실패:', error);
    res.status(500).json({ error: '전입신자 교육 관리 목록 조회 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 교육 관리 데이터 추가/수정
router.post('/education', authenticateToken, async (req, res) => {
  let conn;
  try {
    const {
      id,
      teacher,
      believer_name,
      believer_type,
      education_type,
      week1_date,
      week2_date,
      week3_date,
      week4_date,
      week5_date,
      week6_date,
      week7_date,
      week8_date,
      week1_comment,
      week2_comment,
      week3_comment,
      week4_comment,
      week5_comment,
      week6_comment,
      week7_comment,
      week8_comment,
      overall_comment,
      file_id
    } = req.body;
    
    conn = await pool.getConnection();
    
    if (id) {
      // 수정 - 교육 데이터만 업데이트
      const updateSql = `
        UPDATE new_comer_education SET
          week1_date = ?,
          week2_date = ?,
          week3_date = ?,
          week4_date = ?,
          week5_date = ?,
          week6_date = ?,
          week7_date = ?,
          week8_date = ?,
          week1_comment = ?,
          week2_comment = ?,
          week3_comment = ?,
          week4_comment = ?,
          week5_comment = ?,
          week6_comment = ?,
          week7_comment = ?,
          week8_comment = ?,
          overall_comment = ?,
          file_id = ?,
          updated_at = NOW()
        WHERE id = ?
      `;
      
      const updateParams = [
        week1_date, week2_date, week3_date, week4_date,
        week5_date, week6_date, week7_date, week8_date,
        week1_comment, week2_comment, week3_comment, week4_comment,
        week5_comment, week6_comment, week7_comment, week8_comment,
        overall_comment, file_id, id
      ];
      
      await conn.query(updateSql, updateParams);
      
      // 새로운 등록번호가 생성된 경우 응답에 포함
      const responseData = { 
        message: '전입신자 교육 관리 데이터가 성공적으로 수정되었습니다.' 
      };
      
      if (res.locals.newRegistrationNumber) {
        responseData.newRegistrationNumber = res.locals.newRegistrationNumber;
        console.log('응답에 새로운 등록번호 포함:', res.locals.newRegistrationNumber);
      }
      
      res.json(responseData);
    } else {
      // 추가 - 전입신자 ID를 찾아서 교육 데이터 생성
      const transferBelieverResult = await conn.query(
        'SELECT id FROM new_comers WHERE name = ? AND believer_type = ? AND department = ?',
        [believer_name, believer_type, '새가족위원회']
      );
      
      if (transferBelieverResult.length === 0) {
        return res.status(404).json({ error: '해당 전입신자를 찾을 수 없습니다.' });
      }
      
      const transferBelieverId = transferBelieverResult[0].id;
      
      const insertSql = `
        INSERT INTO new_comer_education (
          new_comer_id,
          week1_date,
          week2_date,
          week3_date,
          week4_date,
          week5_date,
          week6_date,
          week7_date,
          week8_date,
          week1_comment,
          week2_comment,
          week3_comment,
          week4_comment,
          week5_comment,
          week6_comment,
          week7_comment,
          week8_comment,
          overall_comment,
          file_id,
          created_at,
          updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `;
      
      const insertParams = [
        transferBelieverId,
        week1_date, week2_date, week3_date, week4_date,
        week5_date, week6_date, week7_date, week8_date,
        week1_comment, week2_comment, week3_comment, week4_comment,
        week5_comment, week6_comment, week7_comment, week8_comment,
        overall_comment, file_id
      ];
      
      const result = await conn.query(insertSql, insertParams);
      
      res.json({ 
        message: '전입신자 교육 관리 데이터가 성공적으로 추가되었습니다.',
        id: result.insertId
      });
    }
  } catch (error) {
    console.error('전입신자 교육 관리 데이터 추가/수정 실패:', error);
    res.status(500).json({ error: '전입신자 교육 관리 데이터 추가/수정 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 교육 관리 연도 조회
router.get('/education/years', authenticateToken, async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const sql = `
      SELECT DISTINCT year 
      FROM new_comers 
      WHERE believer_type = '전입신자' AND department = '새가족위원회'
      ORDER BY year DESC
    `;
    
    const rows = await conn.query(sql);
    const years = rows.map(row => row.year);
    
    res.json(years);
  } catch (error) {
    console.error('전입신자 교육 관리 연도 조회 실패:', error);
    res.status(500).json({ error: '전입신자 교육 관리 연도 조회 중 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

// 전입신자 교육 관리용 교육 데이터 생성 또는 업데이트 (new_comer_id 기준)
router.put('/education/new-comer/:new_comer_id', authenticateToken, async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { new_comer_id } = req.params;
    const {
      week1_date,
      week2_date,
      week3_date,
      week4_date,
      week5_date,
      week6_date,
      week7_date,
      week8_date,
      week1_comment,
      week2_comment,
      week3_comment,
      week4_comment,
      week5_comment,
      week6_comment,
      week7_comment,
      week8_comment,
      overall_comment,
      file_id,
      believer_type, // 신자구분 추가
      department     // 부서 추가
    } = req.body;
    
    console.log('=== 전입신자교육관리 교육 데이터 생성/업데이트 시작 ===');
    console.log('new_comer_id:', new_comer_id);
    console.log('요청 데이터:', req.body);
    
    // 신자구분 변경 시 등록번호 처리 (전입신자 수정 API와 동일한 로직)
    if (believer_type) {
      // 현재 신자 정보 조회 (신자구분 변경 확인용)
      const existingDataResult = await conn.query(
        'SELECT believer_type, number, year, department FROM new_comers WHERE id = ?', 
        [new_comer_id]
      );
      
      if (existingDataResult.length === 0) {
        return res.status(404).json({ error: '해당 신자를 찾을 수 없습니다.' });
      }
      
      const existingBelieverType = existingDataResult[0]?.believer_type;
      const originalNumber = existingDataResult[0]?.number;
      const existingYear = existingDataResult[0]?.year;
      const existingDepartment = existingDataResult[0]?.department;
      
      console.log('=== 신자구분 변경 확인 ===');
      console.log('기존 신자구분:', existingBelieverType);
      console.log('새 신자구분:', believer_type);
      console.log('기존 번호:', originalNumber);
      console.log('기존 년도:', existingYear);
      console.log('기존 부서:', existingDepartment);
      
      // 신자구분에 따른 번호 처리
      let finalNumber = originalNumber;
      let shouldReorderNumbers = false;
      
      if (existingBelieverType !== believer_type) {
        console.log('신자구분 변경 감지');
        
        if (existingBelieverType === '전입신자' && believer_type === '초신자') {
          // 전입신자 → 초신자: 새로운 초신자 번호 생성
          console.log('전입신자 → 초신자 변경: 새로운 번호 생성');
          shouldReorderNumbers = true;
          
          // 년도에서 마지막 2자리 추출
          const yearSuffix = existingYear ? existingYear.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
          
          // 부서, 신자유형(초신자), 년도 기준으로 순번 조회
          const rowNumberQuery = `
            SELECT COUNT(*) as current_count
            FROM new_comers 
            WHERE department = ? AND believer_type = ? AND year = ?
          `;
          
          const rowNumberResult = await conn.query(rowNumberQuery, [existingDepartment, believer_type, existingYear]);
          const currentCount = parseInt(rowNumberResult[0]?.current_count) || 0;
          const nextNumber = currentCount + 1;
          finalNumber = `${yearSuffix}-${String(nextNumber).padStart(3, '0')}`;
          
          console.log('초신자 현재 등록된 수:', currentCount);
          console.log('초신자 다음 순번:', nextNumber);
          console.log('초신자 생성된 번호:', finalNumber);
          
        } else if (existingBelieverType === '초신자' && believer_type === '전입신자') {
          // 초신자 → 전입신자: 새로운 전입신자 번호 생성
          console.log('초신자 → 전입신자 변경: 새로운 번호 생성');
          shouldReorderNumbers = true;
          
          // 년도에서 마지막 2자리 추출
          const yearSuffix = existingYear ? existingYear.toString().slice(-2) : new Date().getFullYear().toString().slice(-2);
          
          // 부서, 신자유형(전입신자), 년도 기준으로 순번 조회
          const rowNumberQuery = `
            SELECT COUNT(*) as current_count
            FROM new_comers 
            WHERE department = ? AND believer_type = ? AND year = ?
          `;
          
          const rowNumberResult = await conn.query(rowNumberQuery, [existingDepartment, believer_type, existingYear]);
          const currentCount = parseInt(rowNumberResult[0]?.current_count) || 0;
          const nextNumber = currentCount + 1;
          finalNumber = `${yearSuffix}-${String(nextNumber).padStart(3, '0')}`;
          
          console.log('전입신자 현재 등록된 수:', currentCount);
          console.log('전입신자 다음 순번:', nextNumber);
          console.log('전입신자 생성된 번호:', finalNumber);
        }
        
        // 신자구분과 등록번호 업데이트
        await conn.query(
          'UPDATE new_comers SET believer_type = ?, number = ? WHERE id = ?',
          [believer_type, finalNumber, new_comer_id]
        );
        
        console.log('new_comers 테이블 업데이트 완료');
        
        // 응답에 새로운 등록번호 포함
        res.locals.newRegistrationNumber = finalNumber;
        
        // 신자구분 변경으로 인한 번호 재정렬
        if (shouldReorderNumbers) {
          console.log('=== 번호 재정렬 시작 ===');
          
          // 전입신자 → 초신자 변경인 경우 전입신자 번호 재정렬
          if (existingBelieverType === '전입신자' && believer_type === '초신자') {
            console.log('전입신자 → 초신자 변경: 전입신자 번호 재정렬');
            try {
              const reorderResponse = await fetch(`${req.protocol}://${req.get('host')}/api/transfer-believers/reorder-numbers`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': req.headers.authorization
                },
                body: JSON.stringify({
                  year: existingYear,
                  department: existingDepartment
                })
              });
              
              if (reorderResponse.ok) {
                const reorderData = await reorderResponse.json();
                console.log('전입신자 번호 재정렬 완료:', reorderData.message);
                console.log('재정렬된 전입신자 수:', reorderData.updatedCount);
              } else {
                console.error('전입신자 번호 재정렬 실패');
              }
            } catch (error) {
              console.error('전입신자 번호 재정렬 중 오류:', error);
            }
          }
          // 초신자 → 전입신자 변경인 경우 초신자 번호 재정렬
          else if (existingBelieverType === '초신자' && believer_type === '전입신자') {
            console.log('초신자 → 전입신자 변경: 초신자 번호 재정렬');
            try {
              const reorderResponse = await fetch(`${req.protocol}://${req.get('host')}/api/new-comers/reorder-numbers`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': req.headers.authorization
                },
                body: JSON.stringify({
                  year: existingYear,
                  department: existingDepartment
                })
              });
              
              if (reorderResponse.ok) {
                const reorderData = await reorderResponse.json();
                console.log('초신자 번호 재정렬 완료:', reorderData.message);
                console.log('재정렬된 초신자 수:', reorderData.updatedCount);
              } else {
                console.error('초신자 번호 재정렬 실패');
              }
            } catch (error) {
              console.error('초신자 번호 재정렬 중 오류:', error);
            }
          }
        }
      }
    }
    
    console.log('=== 전입신자교육관리 교육 데이터 생성/업데이트 시작 ===');
    console.log('new_comer_id:', new_comer_id);
    console.log('요청 데이터:', req.body);
    
    // 빈 문자열을 null로 변환하는 함수
    const convertEmptyToNull = (value) => {
      return value === '' || value === null || value === undefined ? null : value;
    };
    
    // 날짜 필드들을 null로 변환
    const processedData = {
      week1_date: convertEmptyToNull(week1_date),
      week2_date: convertEmptyToNull(week2_date),
      week3_date: convertEmptyToNull(week3_date),
      week4_date: convertEmptyToNull(week4_date),
      week5_date: convertEmptyToNull(week5_date),
      week6_date: convertEmptyToNull(week6_date),
      week7_date: convertEmptyToNull(week7_date),
      week8_date: convertEmptyToNull(week8_date),
      week1_comment: convertEmptyToNull(week1_comment),
      week2_comment: convertEmptyToNull(week2_comment),
      week3_comment: convertEmptyToNull(week3_comment),
      week4_comment: convertEmptyToNull(week4_comment),
      week5_comment: convertEmptyToNull(week5_comment),
      week6_comment: convertEmptyToNull(week6_comment),
      week7_comment: convertEmptyToNull(week7_comment),
      week8_comment: convertEmptyToNull(week8_comment),
      overall_comment: convertEmptyToNull(overall_comment)
    };
    
    console.log('처리된 데이터:', processedData);
    
    // 기존 교육 데이터 확인
    const existingDataResult = await conn.query(
      'SELECT id FROM new_comer_education WHERE new_comer_id = ?', 
      [new_comer_id]
    );
    
    if (existingDataResult.length > 0) {
      // 기존 데이터가 있으면 업데이트
      console.log('기존 교육 데이터 발견, 업데이트 진행');
      const educationId = existingDataResult[0].id;
      
      const updateQuery = `
        UPDATE new_comer_education SET
          week1_date = ?,
          week2_date = ?,
          week3_date = ?,
          week4_date = ?,
          week5_date = ?,
          week6_date = ?,
          week7_date = ?,
          week8_date = ?,
          week1_comment = ?,
          week2_comment = ?,
          week3_comment = ?,
          week4_comment = ?,
          week5_comment = ?,
          week6_comment = ?,
          week7_comment = ?,
          week8_comment = ?,
          overall_comment = ?,
          file_id = ?,
          updated_at = NOW()
        WHERE id = ?
      `;
      
      const updateParams = [
        processedData.week1_date,
        processedData.week2_date,
        processedData.week3_date,
        processedData.week4_date,
        processedData.week5_date,
        processedData.week6_date,
        processedData.week7_date,
        processedData.week8_date,
        processedData.week1_comment,
        processedData.week2_comment,
        processedData.week3_comment,
        processedData.week4_comment,
        processedData.week5_comment,
        processedData.week6_comment,
        processedData.week7_comment,
        processedData.week8_comment,
        processedData.overall_comment,
        file_id,
        educationId
      ];
      
      const updateResult = await conn.query(updateQuery, updateParams);
      console.log('교육 데이터 업데이트 완료');
      
      // 수료 상태인 경우 양육 시작일/종료일 업데이트
      if (req.body.education_type === '수료') {
        console.log('수료 상태 감지, 양육 시작일/종료일 업데이트 시작');
        
        // 1주차와 마지막 주차 일자 찾기
        const weekDates = [
          processedData.week1_date,
          processedData.week2_date,
          processedData.week3_date,
          processedData.week4_date,
          processedData.week5_date,
          processedData.week6_date,
          processedData.week7_date,
          processedData.week8_date
        ].filter(date => date !== null); // null이 아닌 날짜만 필터링
        
        if (weekDates.length > 0) {
          const educationStartDate = weekDates[0]; // 첫 번째 주차 (1주차)
          const educationEndDate = weekDates[weekDates.length - 1]; // 마지막 주차
          
          console.log('양육 시작일:', educationStartDate);
          console.log('양육 종료일:', educationEndDate);
          
          // new_comers 테이블의 양육 시작일/종료일 업데이트
          await conn.query(
            'UPDATE new_comers SET education_start_date = ?, education_end_date = ?, education_type = ?, graduate_transfer_status = ?, updated_at = NOW() WHERE id = ?',
            [educationStartDate, educationEndDate, '수료', '전송대기', new_comer_id]
          );
          
          console.log('양육 시작일/종료일 업데이트 완료');
        }
      }
      
    } else {
      // 기존 데이터가 없으면 새로 생성
      console.log('기존 교육 데이터 없음, 새로 생성 진행');
      
      const insertQuery = `
        INSERT INTO new_comer_education (
          new_comer_id,
          week1_date,
          week2_date,
          week3_date,
          week4_date,
          week5_date,
          week6_date,
          week7_date,
          week8_date,
          week1_comment,
          week2_comment,
          week3_comment,
          week4_comment,
          week5_comment,
          week6_comment,
          week7_comment,
          week8_comment,
          overall_comment,
          file_id
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `;
      
      const insertParams = [
        new_comer_id,
        processedData.week1_date,
        processedData.week2_date,
        processedData.week3_date,
        processedData.week4_date,
        processedData.week5_date,
        processedData.week6_date,
        processedData.week7_date,
        processedData.week8_date,
        processedData.week1_comment,
        processedData.week2_comment,
        processedData.week3_comment,
        processedData.week4_comment,
        processedData.week5_comment,
        processedData.week6_comment,
        processedData.week7_comment,
        processedData.week8_comment,
        processedData.overall_comment,
        file_id
      ];
      
      console.log('생성 쿼리:', insertQuery);
      console.log('생성 파라미터:', insertParams);
      
      const insertResult = await conn.query(insertQuery, insertParams);
      console.log('=== 교육 데이터 생성 완료 ===');
      
      // 수료 상태인 경우 양육 시작일/종료일 업데이트
      if (req.body.education_type === '수료') {
        console.log('수료 상태 감지, 양육 시작일/종료일 업데이트 시작');
        
        // 1주차와 마지막 주차 일자 찾기
        const weekDates = [
          processedData.week1_date,
          processedData.week2_date,
          processedData.week3_date,
          processedData.week4_date,
          processedData.week5_date,
          processedData.week6_date,
          processedData.week7_date,
          processedData.week8_date
        ].filter(date => date !== null); // null이 아닌 날짜만 필터링
        
        if (weekDates.length > 0) {
          const educationStartDate = weekDates[0]; // 첫 번째 주차 (1주차)
          const educationEndDate = weekDates[weekDates.length - 1]; // 마지막 주차
          
          console.log('양육 시작일:', educationStartDate);
          console.log('양육 종료일:', educationEndDate);
          
          // new_comers 테이블의 양육 시작일/종료일 업데이트
          await conn.query(
            'UPDATE new_comers SET education_start_date = ?, education_end_date = ?, education_type = ?, graduate_transfer_status = ?, updated_at = NOW() WHERE id = ?',
            [educationStartDate, educationEndDate, '수료', '전송대기', new_comer_id]
          );
          
          console.log('양육 시작일/종료일 업데이트 완료');
        }
      }
      
      // 새로운 등록번호가 생성된 경우 응답에 포함
      const responseData = { 
        id: insertResult.insertId,
        message: '전입신자 교육 데이터가 성공적으로 생성되었습니다.' 
      };
      
      if (res.locals.newRegistrationNumber) {
        responseData.newRegistrationNumber = res.locals.newRegistrationNumber;
        console.log('응답에 새로운 등록번호 포함:', res.locals.newRegistrationNumber);
      }
      
      res.status(201).json(responseData);
    }
    
  } catch (error) {
    console.error('전입신자교육관리 교육 데이터 처리 오류:', error);
    res.status(500).json({ error: '서버 오류가 발생했습니다.' });
  } finally {
    if (conn) conn.release();
  }
});

module.exports = router; 